type TxnResult = 
 variant {
   err:
    record {
      code:
       variant {
         InsufficientAllowance;
         InsufficientBalance;
         InsufficientGas;
         LockedTransferExpired;
         UndefinedError;
       };
      message: text;
    };
   ok: Txid;
 };
type TxnRecord = 
 record {
   caller: principal;
   gas: Gas;
   index: nat;
   nonce: nat;
   timestamp: Time;
   transaction: Transaction;
   txid: Txid;
 };
type TxnQueryResponse = 
 variant {
   getTxn: opt TxnRecord;
   lastTxids: vec Txid;
   lastTxidsGlobal: vec Txid;
   lockedTxns: record {
                 lockedBalance: nat;
                 txns: vec TxnRecord;
               };
   txnCount: nat;
   txnCountGlobal: nat;
   getEvents: vec TxnRecord;
 };
type TxnQueryRequest = 
 variant {
   getTxn: record {txid: Txid;};
   lastTxids: record {owner: Address;};
   lastTxidsGlobal;
   lockedTxns: record {owner: Address;};
   txnCount: record {owner: Address;};
   txnCountGlobal;
   getEvents: record {owner: opt Address;};
 };
type Txid = blob;
type Transaction = 
 record {
   data: opt blob;
   from: AccountId;
   operation: Operation;
   to: AccountId;
   value: nat;
 };
type Time = int;
type Subscription = 
 record {
   callback: Callback;
   msgTypes: vec MsgType;
 };
type Operation = 
 variant {
   approve: record {allowance: nat;};
   executeTransfer: record {
                      fallback: nat;
                      lockedTxid: Txid;
                    };
   lockTransfer: record {
                   decider: AccountId;
                   expiration: Time;
                   locked: nat;
                 };
   transfer: record {action: variant {
                               burn;
                               mint;
                               send;
                             };};
 };
type MsgType = 
 variant {
   onApprove;
   onExecute;
   onLock;
   onTransfer;
 };
type Metadata = 
 record {
   content: text;
   name: text;
 };
type Gas = 
 variant {
   cycles: nat;
   noFee;
   token: nat;
 };
type ExecuteType = 
 variant {
   fallback;
   sendAll;
   send: nat;
 };
type Callback = func (TxnRecord) -> ();
type Allowance = 
 record {
   remaining: nat;
   spender: AccountId;
 };
type Address = text;
type AccountId = blob;
service : {
  allowance: (Address, Address) -> (nat) query;
  approvals: (Address) -> (vec Allowance) query;
  approve: (Address, nat, opt vec nat8) -> (TxnResult);
  balanceOf: (Address) -> (nat) query;
  cyclesBalanceOf: (Address) -> (nat) query;
  cyclesReceive: (opt Address) -> (nat);
  decimals: () -> (nat8) query;
  executeTransfer: (Txid, ExecuteType, opt vec nat8) -> (TxnResult);
  gas: () -> (Gas) query;
  lockTransfer: (Address, nat, nat32, opt Address, opt vec nat8, opt blob) ->
   (TxnResult);
  lockTransferFrom: (Address, Address, nat, nat32, opt Address, opt vec nat8,
   opt blob) -> (TxnResult);
  metadata: () -> (vec Metadata) query;
  name: () -> (text) query;
  standard: () -> (text) query;
  subscribe: (Callback, vec MsgType, opt vec nat8) -> (bool);
  subscribed: (Address) -> (opt Subscription) query;
  symbol: () -> (text) query;
  totalSupply: () -> (nat) query;
  transfer: (Address, nat, opt vec nat8, opt blob) -> (TxnResult);
  transferFrom: (Address, Address, nat, opt vec nat8, opt blob) -> (TxnResult);
  txnQuery: (TxnQueryRequest) -> (TxnQueryResponse) query;
}