***
DRC: 202  
Title: Token Transaction Records Storage Standard  
Author: Avida <avida.life@hotmail.com>, Simpson <icpstaking-wei@hotmail.com>  
Status: Draft  
Category: Token DRC  
Created: 2021-12-10
***

## Abstract

DRC202 is a standard for scalable storage of token transaction records. It supports multi-token storage, automatic scaling to create storage canisters (buckets), and automatic routing of query records.

## Motivation

Since the storage capacity of canister is limited (currently only 4G), a scalable external storage solution for tokens needs to be developed.

The DRC202 standard storage mechanism is made up of an entry contract Proxy and multiple auto-scaling storage contracts Buckets. Proxy creates buckets according to the actual storage requirements (a new Bucket is created when one is full), and then compresses the transaction records and stores them in the Bucket. When you want to query a token transaction record, you can first query the bucketId where the record is stored from the Proxy contract (using BloomFilter technology for routing, https://en.wikipedia.org/wiki/Bloom_filter ), and then query the transaction record from the specified Bucket.

![DRC202](202.jpg)

## Specification

**NOTES**:

- The following specifications use syntax from Candid.
- The `sid` is the globally unique transaction record storage ID, generated by the Proxy contract.
- The `txid` is a unique transaction record ID within a token, generated by the Token contract. Recommended method of generating txid: convert token's canisterId, caller's accountId, and caller's nonce (i.e. txn index) into [nat8] arrays respectively, and join them together as `txInfo: [nat8]`. Then get the `txid` value as "000000"(big-endian 4-bytes, `encode(caller.nonce)`) + "0000..00"(28-bytes,`sha224(txInfo)`). 

### Types (DID)

``` candid
type Token = principal;
type Txid = blob;
type Time = int;
type Bucket = principal;
type AccountId = blob;
type Sid = blob;
type Gas = variant {
   cycles: nat;
   noFee;
   token: nat;
};
type TxnRecord = record {
   caller: AccountId;
   gas: Gas;
   index: nat;
   msgCaller: opt principal;
   nonce: nat;
   timestamp: Time;
   transaction: Transaction;
   txid: Txid;
};
type Transaction = record {
   data: opt blob;
   from: AccountId;
   operation: Operation;
   to: AccountId;
   value: nat;
};
type Operation = variant {
   approve: record {allowance: nat;};
   executeTransfer: record { fallback: nat; lockedTxid: Txid; };
   lockTransfer: record { decider: AccountId; expiration: Time; locked: nat; };
   transfer: record {action: variant { burn; mint; send; };};
};
type TokenInfo = record {
   count: nat;
   lastIndex: nat;
   lastTxid: Txid;
};
type BucketInfo = record {
   count: nat;
   cycles: nat;
   heap: nat;
   memory: nat;
   stableMemory: nat32;
};
type ProxyActor = service {
   bucket: (Token, Txid, nat, opt nat8) -> (opt Bucket) query;
   bucketInfo: (opt Bucket) -> (Bucket, BucketInfo);
   fee: () -> (nat) query;
   generateTxid: (Token, AccountId, nat) -> (Txid) query;
   getLastTxns: () -> (vec record { nat; Token; nat; Txid; }) query;
   maxBucketMemory: () -> (nat) query;
   setFee: (nat) -> (bool);
   setMaxMemory: (nat) -> (bool);
   standard: () -> (text) query;
   stats: () -> (record {
       bucketCount: nat;
       errCount: nat;
       storeErrPool: nat;
       tokenCount: nat;
       txnCount: nat;
   }) query;
   store: (TxnRecord) -> ();
   storeBytes: (Txid, vec nat8) -> ();
   version: () -> (nat8) query;
};

type BucketActor = service {
   bucketInfo: () -> (BucketInfo) query;
   last: () -> (Sid, Time) query;
   txn: (Token, Txid) -> (opt record { TxnRecord; Time; }) query;
   txnBytes: (Token, Txid) -> (opt record { vec nat8; Time; }) query;
   txnBytes2: (Sid) -> (opt record { vec nat8; Time; }) query;
};
```

### DRC202.ProxyActor

ProxyActor is a proxy contract for transaction record storage that automatically creates and manages Bucket contracts.

#### standard

Returns standard name.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
standard: () -> (text) query;
```

#### version

Returns version value.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
version: () -> (nat8) query;
```

#### fee

Returns the fee (cycles) to be paid for storing a transaction record.

``` candid
fee: () -> (cycles: nat) query;
```

#### store

Store a transaction record `_txn`.

``` candid
store: (_txn: TxnRecord) -> ();
```

#### storeBytes

Store a transaction record `_data` in binary data format, the maximum data length allowed is 128KB.

``` candid
storeBytes: (_txid: Txid, _data: vec nat8) -> ();
```
#### getLastTxns

Returns the latest stored transaction records.

``` candid
getLastTxns: () -> (vec record { index: nat; token: Token; indexInToken: nat; txid: Txid; }) query;
```

#### bucket

Returns the bucket in which the transaction record `_txid` for the specified token `_token` (default `_step` is 0). This query is not always accurate due to the use of a BloomFilter as a route. If the target transaction record is not in that bucket, you can re-query the bucket by `step+1` until null is returned.

``` candid
bucket: (_token: Token, _txid: Txid, _step: nat, _version: opt nat8) -> (opt Bucket) query;
```

#### generateTxid

Generates txid based on the given token `_token`, accountId `_caller`, nonce `_nonce` values.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
generateTxid: (_token: Token, _caller: AccountId, _nonce: nat) -> (Txid) query;
```

#### stats

Returns statistics.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
stats: () -> (record { bucketCount: nat; errCount: nat; storeErrPool: nat; tokenCount: nat; txnCount: nat; }) query;
```

#### bucketInfo

Returns information about the bucket `_bucket`. If no `_bucket` is specified, returns the current bucket information.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
bucketInfo: (_bucket: opt Bucket) -> (Bucket, BucketInfo);
```
#### maxBucketMemory

Returns the maximum allowed storage capacity of each bucket being set.   
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
maxBucketMemory: () -> (nat) query;
```

#### setMaxMemory

Sets the maximum allowed storage capacity `_memory` for each bucket.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
setMaxMemory: (_memory: nat) -> (bool);
```

#### setFee

Sets the amount of cycles `_fee` to be paid for each transaction record stored.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
setFee: (_fee: nat) -> (bool);
```


### DRC202.BucketActor

BucketActor is used to store transaction record data and to implement the public query interface.

#### txn

Returns the transaction record for the specified `_token` and `_txid`.

``` candid
txn: (_token: Token, _txid: Txid) -> (opt record { TxnRecord; Time; }) query;
```

#### txnBytes

Returns the binary data of the transaction record for the specified `_token` and `_txid`. 

``` candid
txnBytes: (_token: Token, _txid: Txid) -> (opt record { vec nat8; Time; }) query;
```

#### bucketInfo 

Returns information about the current bucket.   
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
bucketInfo: () -> (BucketInfo) query;
```

#### last

Returns the sid and timestamp of the last record stored.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
last: () -> (Sid, Time) query;
```

#### txnBytes2

Returns the binary data of the transaction record for the specified `_sid`.    
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
txnBytes2: (_sid: Sid) -> (opt record { vec nat8; Time; }) query;
```


## Implementation

Different implementations are being written by various teams.

#### Example implementations

- [ICLighthouse](https://github.com/iclighthouse/DRC_standards/tree/main/DRC202/examples/IClighthouse)
    ICTokens DRC202: y5a36-liaaa-aaaak-aacqa-cai
