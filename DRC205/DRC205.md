***
DRC: 205  
Title: Swap Transaction Records Storage Standard   
Author: Avida <avida.life@hotmail.com>, Simpson <icpstaking-wei@hotmail.com>  
Status: Draft  
Category: Swap DRC  
Created: 2021-12-10
***

## Abstract

DRC205 is a standard for scalable storage of swap transaction records. It supports multi-dex storage, automatic scaling to create storage canisters (buckets), and automatic routing of query records.

![DRC205](drc205.jpg)

## Motivation

Dex's transaction records have a need to a persistent and transparent storage, and therefore require a scalable external storage solution.

The DRC205 standard consists of three parts.

* Swap transaction record data structure (TxnRecord): Defines a generic data structure that adapts to AMM and OrderBook schemas of Dex, taking into account data transparency and privacy protection.

* Scalable storage interface specification: Scalable storage mechanism is made up of an entry contract Proxy and multiple auto-scaling storage contracts Buckets. Proxy creates buckets according to the actual storage requirements (a new Bucket is created when one is full), and then compresses the transaction records and stores them in the Bucket. When you want to query a transaction record, you can first query the bucketId where the record is stored from the Proxy contract (using BloomFilter technology for routing, https://en.wikipedia.org/wiki/Bloom_filter ), and then query the transaction record from the specified Bucket.

* Dapp Development Kits (Motoko Module) & Guide: It is recommended that Dex developers adopt a transaction record storage specification that takes the model of "recent records cached in the current Canister + historical records persistently stored in the external Canister" and provides a query interface.


## Development Guide

DRC205Proxy Canister-id: 6ylab-kiaaa-aaaak-aacga-cai   
ICHouse Explorer: https://637g5-siaaa-aaaaj-aasja-cai.raw.ic0.app/swaps

DRC205Proxy Canister-id (Test): ix3cb-4iaaa-aaaak-aagbq-cai  
ICHouse Explorer (Test): https://637g5-siaaa-aaaaj-aasja-cai.raw.ic0.app/SwapsTest

About Txid: txid is a blob type, it is the key of a transaction record. if your txid is a nat type or other type, it needs to be converted to a blob type.

### 1. Developing a Dex in Motoko

If you are a Motoko developer working on a Dex, either AMM or OrderBook, you can integrate DRC205 into your Dex using the `DRC205 Module`, example: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/Example.mo   

If you are developing a Dapp with Motoko and just need to query the transaction records, refer to the `How to query transaction records` section below.

### 2. Developing a Dex in Rust

If you are a Rust developer working on a Dex, either AMM or OrderBook, you can call the DRC205Proxy and DRC205Bucket APIs to implement it.
DRC205Proxy did: https://github.com/iclighthouse/DRC_standards/tree/main/DRC205/DRC205Proxy.did   

**Storage of transaction records from your Dex to DRC205 Cansiter**

- Query storage fee

    When you call the storeBatch/storeBytesBatch method of DRC205Proxy, you need to pay the fee in Cycles and pay once for permanent storage. The `DRC205Proxy.fee()` method allows you to query the storage cost `fee` per record.

- Storing records using DRC205 TxnRecord type

    If you convert the transaction records to DRC205 TxnRecord type, you can call the `DRC205Proxy.storeBatch()` method for batch storage.
    ```
    storeBatch: (_txns: vec TxnRecord) -> ();
    ```
    Note: Calling this method requires adding `size(_txns) * fee` Cycles as a fee. To prevent overloading of DRC205, you need to call it only once at 20 second intervals. Please cache the records locally and call this method at intervals for batch storage.

- Storing records using custom type (Not recommended)

    If you are using custom types for your transaction records, you need to convert the records to Bytes (vec nat8) format first and then call the `DRC205Proxy.storeBytesBatch()` method for batch storage.
    ```
    storeBytesBatch: (_txns: vec record { Txid; vec nat8 }) -> ();
    ```
    Note: Calling this method requires adding `size(_txns) * fee` Cycles as a fee. To prevent overloading of DRC205, you need to call it only once at 20 second intervals. Please cache the records locally and call this method at intervals for batch storage.

**Query transaction records from DRC205 Cansiter**

If you need to query trading pair's transaction records in Dapp, refer to the `How to query transaction records` section below.

### 3. Implementing a interface in Dex for the IChouse Explorer

```
/// returns DRC205Proxy canister-id
drc205_canisterId: () -> (principal) query;
/// returns events. Address (Text type) is Principal or AccountId. If Address is not specified means to query all latest transaction records.
drc205_events: (opt Address) -> (vec TxnRecord) query;
/// returns txn record. Query txn record in trading pair canister cache.
drc205_txn: (Txid) -> (opt TxnRecord) query;
```

### 4. How to query transaction records

Whether you are a Rust, Motoko, or front-end developer, you need to provide the trading pair's appId (canister-id) and txid if you want to query the transaction records in DRC205. It is not possible to iterate through and query all records.
DRC205Proxy did: https://github.com/iclighthouse/DRC_standards/tree/main/DRC205/DRC205Proxy.did   
DRC205Bucket did: https://github.com/iclighthouse/DRC_standards/tree/main/DRC205/DRC205Bucket.did   

- Motoko Developers

    If you are a Motoko developer, you can use the get/get2 method of the `DRC205 Module` to query transaction records.

- Other developers

    Steps for query.

    **Step 1**. Get the bucket canister-id where the transaction record is stored by querying DRC205Proxy

    Specify the trading pair's appId (canister-id) and the txid of the transaction record, call `DRC205Proxy.bucket()` method to query the bucket canister-id where the record is stored, if it returns `null`, it means the record does not exist.  
    Note: Due to the use of BloomFilter technology, there is a very small probability (about 1‰) that the record does not exist in the returned bucket, which requires you to continue calling the `DRC205Proxy.bucket()` method using the `_step` parameter + 1. If `null` is returned it means the record must not exist.

    **Step 2**. Query the transaction record via DRC205Bucket

    1) If the trading pair uses the DRC205 TxnRecord type, call the `DRC205Bucket.txn()` or `DRC205Bucket.txnHistory()` method to look up the record based on the Bucket canister-id obtained in the previous step. If `null` is returned, there is a very small chance that the record exists in another bucket and you can let the `_step` parameter +1 and continue back to the previous step for the operation.

    2) If the trading pair uses a custom type for records, call the `DRC205Bucket.txnBytes()` or `DRC205Bucket.txnBytesHistory()` method to look up the record based on the Bucket canister-id obtained in the previous step. If `null` is returned, there is a very small chance that the record exists in another bucket, and you can let the `_step` parameter + 1 and continue back to the previous step for the operation.



## Specification

**NOTES**:

- The following specifications use syntax from Candid.
- The `Sid` is the globally unique transaction record storage ID, Blob type, 32 bytes, generated by the Proxy contract.
- The `Txid` is a unique transaction record ID within a dapp, Blob type, SHOULD be 32 bytes, generated by the dapp contract. Recommended method of generating txid: [DRC205.generateTxid(_app: Principal, _caller: AccountId, _nonce: Nat)](https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/lib/DRC205Types.mo)。
- The `AccountId` is the identity of the Swap user, Blob type, SHOULD be 32 bytes, generated by the Dex contract. If you use types such as Principal, [Nat8], etc., you need to convert it to 32 bytes Blob.

### Transaction Record Types (TxnRecord)

This is a recommended data structure. If you use a custom data structure, you can use the storeBytes and txnBytes methods to meet compatibility requirements.

``` candid
type Status = variant { Failed; Pending; Completed; PartiallyCompletedAndCancelled; Cancelled; };
type TxnRecord = record {
   account: AccountId;
   caller: AccountId;
   cyclesWallet: opt CyclesWallet;
   data: opt Data;
   details: vec record { counterparty: Txid; token0Value: BalanceChange; token1Value: BalanceChange; };
   fee: record { token0Fee: int; token1Fee: int; };
   index: nat;
   msgCaller: opt principal;
   nonce: Nonce;
   operation: OperationType;
   order: record { token0Value: opt BalanceChange; token1Value: opt BalanceChange; };
   orderMode: variant { AMM; OrderBook; };
   orderType: opt variant { LMT; FOK; FAK; MKT; };
   shares: ShareChange;
   status: Status;
   time: Time;
   token0: TokenType;
   token0Value: BalanceChange;
   token1: TokenType;
   token1Value: BalanceChange;
   txid: Txid;
 };
type Txid = blob;
type TokenType = variant { Cycles; Icp; Token: principal; };
type Time = int;
type Shares = nat;
type ShareChange = variant { Burn: Shares; Mint: Shares; NoChange; };
type OperationType = variant { AddLiquidity; Claim; RemoveLiquidity; Swap; };
type Nonce = nat;
type Data = blob;
type CyclesWallet = principal;
type BucketInfo = record { count: nat;cycles: nat; heap: nat; memory: nat; stableMemory: nat32; };
type Bucket = principal;
type BalanceChange = variant { CreditRecord: nat; DebitRecord: nat; NoChange; };
type AppInfo = record { count: nat; lastIndex: nat; lastTxid: Txid; };
type AppId = principal;
type AccountId = blob;
```

Types in Motoko: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/lib/DRC205Types.mo

See development example annotations for field explanations: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/Example.mo

### Generic storage interfaces (Proxy and Bucket)

#### 1. DRC205Proxy

DRC205Proxy is a proxy canister for transaction record storage that automatically creates and manages Bucket canisters.

#### standard

Returns standard name.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
standard: () -> (text) query;
```

#### version

Returns version value.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
version: () -> (nat8) query;
```

#### fee

Returns the fee (cycles) to be paid for storing a transaction record. Pay once for permanent storage.

``` candid
fee: () -> (cycles: nat) query;
```

#### store

Store a transaction record `_txn`, where `_txn.data` must not exceed 64KB in data length, and any excess will be intercepted. Calling this method requires adding cycles as a cost (fee is queried via the `fee()` method).

``` candid
store: (_txn: TxnRecord) -> ();
```

#### storeBatch

Batch storage of transaction records, allowing storage at intervals of more than 20 seconds. Calling this method requires adding cycles as a cost (fee is queried via the `fee()` method), and batch storage of n messages requires paying n*fee Cycles.

``` candid
storeBatch: (_txns: vec TxnRecord) -> ();
```

#### storeBytes

Store a transaction record `_data` in binary data format, the maximum data length allowed is 128KB. Calling this method requires adding cycles as a cost (fee is queried via the `fee()` method).

``` candid
storeBytes: (_txid: Txid, _data: vec nat8) -> ();
```

#### storeBytesBatch

Batch storage of binary records, allowing storage at intervals of more than 20 seconds. Calling this method requires adding cycles as a cost (fee is queried via the `fee()` method), and batch storage of n messages requires paying n*fee Cycles.

``` candid
storeBytesBatch: (_txns: vec record { Txid; vec nat8 }) -> ();
```

#### getLastTxns

Returns the latest stored transaction records.

``` candid
getLastTxns: () -> (vec record { index: nat; app: AppId; indexInApp: nat; txid: Txid; }) query;
```

#### bucket

Returns the bucket in which the transaction record `_txid` for the specified app `_app` (default `_step` is 0). This query is not always accurate due to the use of a BloomFilter as a route. If the target transaction record is not in that bucket, you can re-query the bucket by `step+1` until  returned null (indicates that the record you want to query does not exist).

``` candid
bucket: (_app: AppId, _txid: Txid, _step: nat, _version: opt nat8) -> (opt Bucket) query;
```

#### generateTxid

Generates txid based on the given app `_app`, accountId `_caller`, nonce `_nonce` values.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
generateTxid: (_app: AppId, _caller: AccountId, _nonce: nat) -> (Txid) query;
```

#### stats

Returns statistics.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
stats: () -> (record { bucketCount: nat; errCount: nat; storeErrPool: nat; tokenCount: nat; txnCount: nat; }) query;
```

#### bucketInfo

Returns information about the bucket `_bucket`. If no `_bucket` is specified, returns the current bucket information.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
bucketInfo: (_bucket: opt Bucket) -> (Bucket, BucketInfo);
```


#### 2. DRC205Bucket

DRC205Bucket is used to store transaction record data and to implement the public query interface.

#### txn

(@deprecated: this method will be deprecated)  
Returns the transaction record for the specified `_app` and `_txid`.

``` candid
txn: (_app: AppId, _txid: Txid) -> (opt record { TxnRecord; Time; }) query;
```

#### txnHistory

Returns the transaction record for the specified `_app` and `_txid`. Returns an array containing the history of all modifications.  

``` candid
txnHistory: (_app: AppId, _txid: Txid) -> (vec record { TxnRecord; Time; }) query;
```

#### txnBytes

(@deprecated: this method will be deprecated)  
Returns the binary data of the transaction record for the specified `_app` and `_txid`. 

``` candid
txnBytes: (_app: AppId, _txid: Txid) -> (opt record { vec nat8; Time; }) query;
```

#### txnBytesHistory

Returns the binary data of the transaction record for the specified `_app` and `_txid`. Returns an array containing the history of all modifications.  

``` candid
txnBytesHistory: (_app: AppId, _txid: Txid) -> (vec record { vec nat8; Time; }) query;
```

#### txnBytes2

Returns the binary data of the transaction record for the specified `_sid`.    
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
txnBytes2: (_sid: Sid) -> (opt record { vec nat8; Time; }) query;
```

#### txnHash

Generate the hash value of the specified transaction record.    
OPTIONAL - This method can be used to improve usability, but the method may not be present.
``` candid
txnHash: (_app: AppId, _txid: Txid, _index: nat) -> (opt text) query;
```

#### txnBytesHash

Generate the hash value of the specified bytes data record.    
OPTIONAL - This method can be used to improve usability, but the method may not be present.
``` candid
txnBytesHash: (_app: AppId, _txid: Txid, _index: nat) -> (opt text) query;
```

#### bucketInfo 

Returns information about the current bucket.   
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
bucketInfo: () -> (BucketInfo) query;
```

#### last

Returns the sid and timestamp of the last record stored.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
last: () -> (Sid, Time) query;
```

### Development Kits (Motoko Module) & Guides

#### DRC205 Module

import DRC205 "lib/DRC205";

#### drc205

Returns the DRC205Proxy Canister object.   

``` candid
drc205: () -> DRC205Types.Self;
```

#### drc205CanisterId

Returns DRC205Proxy canister-id。 

``` candid
drc205CanisterId: () -> principal;
```

#### config

Configure the properties EN_DEBUG, MAX_CACHE_TIME, MAX_CACHE_NUMBER_PER, MAX_STORAGE_TRIES, etc.

``` candid
config: (_config: Config) -> bool;
```

#### getConfig

Returns the configuration information. 

``` candid
getConfig: () -> Setting;
```

#### generateTxid

Generates the txid. 

``` candid
generateTxid : (_app: principal, _caller: AccountId, _nonce: nat) -> Txid;
```

#### get

Finds the record with the specified `_txid` from the current canister cache, or returns null if it does not exist. 

``` candid
get : (_txid: Txid) -> opt TxnRecord;
```

#### put

Caches a record `_txn`.

``` candid
put : (_txn: TxnRecord) -> ();
```

#### store

Asynchronously stores a record into the extended Canister. 

``` candid
store : () -> ();
```
#### get2

Finds the record with the specified `_txid` from the current canister cache, or finds the record from the external canister if it does not exist. This is an asynchronous method.  

``` candid
get : (_txid: Txid) -> opt TxnRecord;
```

#### getLastTxns

Returns a list of latest records txid for user `_account`.  

``` candid
getLastTxns : (_account: opt AccountId) -> vec Txid;
```

#### getEvents

Returns a list of details of the latest records that occurred for user `_account`.

``` candid
getEvents : (_account: opt AccountId) -> vec TxnRecord;
```

#### getData

Returns the data of the drc205 object, which is only used for data backup during upgrade.  

``` candid
getData : () -> DataTemp;
```

#### setData

Sets the data of the drc205 object, which is used only for upgrades.  

``` candid
setData : (_data: DataTemp) -> ();
```


#### Developer's Guide 

Motoko development example: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/Example.mo

**Step1** Importing module files

Puts the folder https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/lib/ into your project directory, and import modules into your code.
``` motoko
import Array "mo:base/Array";
import Principal "mo:base/Principal";
import Time "mo:base/Time";
import DRC205 "lib/DRC205";
``` 

**Step2** Writing codes

Declare private global variables, e.g.
``` motoko
// Set EN_DEBUG=false in the production environment.
private var drc205 = DRC205.DRC205({EN_DEBUG = true; MAX_CACHE_TIME = 3 * 30 * 24 * 3600 * 1000000000; MAX_CACHE_NUMBER_PER = 100; MAX_STORAGE_TRIES = 2; });
``` 

Generates Txid and TxnRecord, execute drc205.put(txn) to store the record into the cache, and execute drc205.store() to store the record into the DRC205 storage canister, e.g.
``` motoko
    public shared(msg) func test(_n: Nat) : async DRC205.Txid{
        let caller = drc205.getAccountId(msg.caller, null);
        let txid = drc205.generateTxid(Principal.fromActor(this), caller, _n);
        var txn: DRC205.TxnRecord = {
            txid = txid; // Transaction id
            msgCaller = null; // Caller principal
            caller = caller; // Caller account (Blob)
            operation = #Swap; // { #AddLiquidity; #RemoveLiquidity; #Claim; #Swap; }
            account = caller; // Swap user account (Blob)
            cyclesWallet = null; // Cycles wallet principal, used only for one of trading pair tokens is cycles.
            token0 = #Token(Principal.fromText("ueghb-uqaaa-aaaak-aaioa-cai")); // Trading pair { #Cycles; #Icp; #Token: Principal; }
            token1 = #Token(Principal.fromText("udhbv-ziaaa-aaaak-aaioq-cai")); // Trading pair { #Cycles; #Icp; #Token: Principal; }
            token0Value = #DebitRecord(10000000000); // #DebitRecord indicates the amount of token0 spent for swapping.
            token1Value = #CreditRecord(20000000000); // #CreditRecord indicates the amount of token1 received from swapping.
            fee = {token0Fee = 0; token1Fee = 20000; }; // fee
            shares = #NoChange; // Liquidity shares change of user. { #Mint: Nat; #Burn: Nat; #NoChange; }
            time = Time.now(); // Timestamp (nanoseconds).
            index = _n;  // Global Index
            nonce = _n;  // Nonce of user
            orderType = #AMM; // Order Type  { #AMM; #OrderBook; }
            details = []; // Counterparty order list, for orderbook mode only.
            data = null; // Attached data (Blob)
        };
        drc205.put(txn); // Put txn to the current canister cache.
        let store = /*await*/ drc205.store(); // Store in the DRC205 scalable bucket.
        return txid;
    };
``` 

**Step3** Writing queries and upgrade functions

It is recommended to implement the following methods in your dapp. (Convenient ic.house explorer query records)

* drc205_getConfig : () -> DRC205.Setting query
* drc205_canisterId : () -> principal query
* drc205_dexInfo : () -> async DRC205.DexInfo query
* drc205_events : (_account: opt DRC205.Address) -> vec DRC205.TxnRecord query
* drc205_txn : (_txid: DRC205.Txid) -> opt DRC205.TxnRecord query
* drc205_txn2 : (_txid: DRC205.Txid) -> opt DRC205.TxnRecord

E.g.
``` motoko
    /// returns setting
    public query func drc205_getConfig() : async DRC205.Setting{
        return drc205.getConfig();
    };
    public query func drc205_canisterId() : async Principal{
        return drc205.drc205CanisterId();
    };
    public query func drc205_dexInfo() : async DRC205.DexInfo{
        return {
            canisterId = Principal.fromActor(this);
            dexName = "icswap"; // your dex name
            pairName = "TEKENA/TOKENB"; // pair name
            token0 = (#Token(Principal.fromText("ueghb-uqaaa-aaaak-aaioa-cai")), #drc20); // token0 info
            token1 = (#Token(Principal.fromText("udhbv-ziaaa-aaaak-aaioq-cai")), #dip20); // token1 info
            feeRate = 0.005; // fee rate
        };
    };
    /// config
    // public shared(msg) func drc205_config(config: DRC205.Config) : async Bool{ 
    //     assert(msg.caller == owner);
    //     return drc205.config(config);
    // };
    /// returns events
    public query func drc205_events(_account: ?DRC205.Address) : async [DRC205.TxnRecord]{
        switch(_account){
            case(?(account)){ return drc205.getEvents(?drc205.getAccountId(Principal.fromText(account), null)); };
            case(_){return drc205.getEvents(null);}
        };
    };
    /// returns txn record. This is a query method that looks for record from this canister cache.
    public query func drc205_txn(_txid: DRC205.Txid) : async (txn: ?DRC205.TxnRecord){
        return drc205.get(_txid);
    };
    /// returns txn record. It's an update method that will try to find txn record in the DRC205 canister if the record does not exist in this canister.
    public shared func drc205_txn2(_txid: DRC205.Txid) : async (txn: ?DRC205.TxnRecord){
        return await drc205.get2(Principal.fromActor(this), _txid);
    };
    // upgrade
    private stable var __drc205Data: [DRC205.DataTemp] = [];
    system func preupgrade() {
        __drc205Data := Array.append(__drc205Data, [drc205.getData()]);
    };
    system func postupgrade() {
        if (__drc205Data.size() > 0){
            drc205.setData(__drc205Data[0]);
            __drc205Data := [];
        };
    };
```


## Examples

#### Implementations

- Storage Canister: https://github.com/iclighthouse/DRC_standards/tree/main/DRC205/examples/IClighthouse  
    DRC205 (Main): 6ylab-kiaaa-aaaak-aacga-cai  
    DRC205 (Test): ix3cb-4iaaa-aaaak-aagbq-cai 
    Notes: Use 6ylab-kiaaa-aaaak-aacga-cai to store swap records that can be queried through the ICHouse blockchain explorer (http://ic.house).

- Motoko Module: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/lib/DRC205.mo 

- Development Example: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/Example.mo   